# Lua-utils-for-Rebel-Galaxy

## требования
* Lua 5.3 (http://www.lua.org/download.html)
* lua-zlib (https://github.com/brimworks/lua-zlib)
* lua-lfs (https://github.com/keplerproject/luafilesystem)

для Win x64 имеется готовый комплект, [lua531_zlib_lfs_x64.zip](https://mega.nz/#!mxgGkYYY!SFJRF2feU_DdMu7L8dH-Syww-uUiO4_qbzDNLFstY8E).

## использование

### работа с .DAT архивами

#### распаковка
````
lua unpack.lua <INPUT.PAK> [OUTPUT/dir]
````
*прим*: выходной каталог должен существовать. без указания происходит вывод содержания архива без распаковки.

к именам всех файлов добавляется цифровой префикс вида *XX_имяфайла*, где *XX* — внутригровой тип ресурса. это требуется для скрипта упаковки, чтобы не хранить тип в отдельном файле.

#### упаковка
````
lua pack.lua <INPUT/dir> [OUTPUT.PAK]
````
*прим*: имя создаваемого архива по умолчанию — *DATA2.PAK* в текущем каталоге. на первом уровне входного каталога должен находится только каталог *MEDIA*.

### ресурсы

#### конвертер DAT -> Lua -> DAT
````
lua dat2lua.lua <INPUT.DAT> [OUTPUT.lua]
lua lua2dat.lua <INPUT.lua> [OUTPUT.DAT]
````
*прим*: без указания второго параметра *dat2lua* направляет вывод в консоль, *lua2dat* — в *OUT.DAT* в текущем каталоге.

конвертация происходит в валидный Lua-скрипт, который и используется для обратного преобразования. в начале файла находится строковый словарь, остальные строковые значения берутся из хеш–таблиц *dict_(types|ext).lua*. в случае отсутствия в словаре хеш записывается как *_XXXXXX*, где *XXXXXX* — его числовое значение.

#### конвертер DAT -> TXT|XML
````
lua dat2txt.lua <INPUT.DAT> [> OUTPUT.txt]
lua dat2xml.lua <INPUT.DAT> [> OUTPUT.xml]
````

в начале идет вывод строкового словаря, далее следует конвертированное содержание файла выглядящее примерно так:
````
[key1] = 'value1',
[key2] = 'value2',
...
[tag1]
  <type>name:value
  [$key3]
    <type>name:$key2:value2
    <$key4>$key5:value
...
  [/$key3]
[/tag1]
````
значение или имя элемента подставляется из файлов *dict_XXX.lua* или из встроенного словаря. если значение не найдено, то оно записывается в виде *$xxx*, где *xxx* — число (код или хеш строки). это позволяет провести обратную конвертацию (WIP).

### проверка хешей
````
lua hasher.lua <STRING1> [STRING2 [STRING3 [...]]
````
подсчет хеша для строки (строк) STRINGx и его вывод (десятичное значение, строка, шестнадцатеричное значение):
````
>lua hasher.lua STRING1 1STRING
1829089533, "STRING1", --0x6D05B0FD
3815255475, "1STRING", --0xE3682DB3
````

### подбор хеша
````
lua hash_brut.lua <HASH> [STRING] [DEPTH]

    HASH   : требуемый хеш
    STRING : неизменяемые начальные символы или пустая строка ("")
    NUMBER : глубина (т. е. количество перебираемых символов)
````
словарь по умолчанию — цифры, латинские буквы в верхнем регистре и символ подчеркивания (````0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_````).

#### примеры
поиск хеша в строке длиной шесть символов начинающейся с ````CHA````:
````
>lua hash_brut.lua 44150820 CHA 3
44150820 CHANCE
keys found: 1
````

полный перебор всех четырехсимвольных комбинаций:
````
>lua hash_brut.lua 7057780 "" 4
7057780 UNJ4
7057780 UNIT
keys founded: 2
````
тут случилась коллизия, так как использованный алгоритм хеширования достаточно неустойчивый.
